def [SYNTAX] PipelineExpression[1,0].Evaluation[R]<(PipelineExpression, LogicalORExpression),false>() = 0:{
  0:access __x0__ = (PipelineExpression "Evaluation")
  0:let argRef = __x0__
  1:app __x1__ = (GetValue argRef)
  1:let arg = [? __x1__]
  2:access __x2__ = (LogicalORExpression "Evaluation")
  2:let funcRef = __x2__
  3:app __x3__ = (GetValue funcRef)
  3:let func = [? __x3__]
  4:if (is-instance-of (typeof funcRef) ReferenceRecord) 4:{
    5:app __x4__ = (IsPropertyReference funcRef)
    5:if (= __x4__ true) 5:{
      6:app __x5__ = (GetThisValue funcRef)
      6:let thisValue = __x5__
    } else 7:{
      8:let refEnv = funcRef.Base
      9:app __x6__ = (refEnv.WithBaseObject refEnv)
      9:let thisValue = __x6__
    }
  } else 4:let thisValue = undefined
  12:if (! (= (typeof func) Object)) 12:throw TypeError else 12:{}
  13:app __x7__ = (IsCallable func)
  13:if (= __x7__ false) 13:throw TypeError else 13:{}
  14:let thisCall = this
  15:app __x8__ = (IsInTailPosition thisCall)
  15:let tailPosition = __x8__
  16:if (= tailPosition true) 16:{
    16:app __x9__ = (PrepareForTailCall)
    16:__x9__
  } else 16:{}
  17:app __x10__ = (Call func thisValue (new [arg]))
  17:let result = __x10__
  20:return result
}
- id: "sec-binary-logical-operators-runtime-semantics-evaluation"
- code:
        1. Let _argRef_ be the result of evaluating |PipelineExpression|.
        1. Let _arg_ be ? GetValue(_argRef_).
        1. Let _funcRef_ be the result of evaluating |LogicalORExpression|.
        1. Let _func_ be ? GetValue(_funcRef_).
        1. If Type(_funcRef_) is a Reference Record, then
          1. If IsPropertyReference(_funcRef_) is *true*, then
            1. Let _thisValue_ be GetThisValue(_funcRef_).
          1. Else the base of _funcRef_ is an Environment Record,
            1. Let _refEnv_ be _funcRef_.[[Base]].
            1. Let _thisValue_ be _refEnv_.WithBaseObject().
        1. Else,
          1. Let _thisValue_ be *undefined*.
        1. If Type(_func_) is not Object, throw a *TypeError* exception.
        1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.
        1. Let _thisCall_ be this |PipelineExpression|.
        1. Let _tailPosition_ be IsInTailPosition(_thisCall_).
        1. If _tailPosition_ is *true*, perform PrepareForTailCall().
        1. Let _result_ be Call(_func_, _thisValue_, « _arg_ »).
        1. Assert: If _tailPosition_ is *true*, the above call will not return here, but instead evaluation will continue as if the following return has already occurred.
        1. Assert: If _result_ is not an abrupt completion, then Type(_result_) is an ECMAScript language type.
        1. Return _result_.